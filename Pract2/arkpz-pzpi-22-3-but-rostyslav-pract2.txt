Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії








ЗВІТ
з практичного заняття №2  
з дисципліни  «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»












Виконав 
ст. гр ПЗПІ-22-3
Бут Ростислав Сергійович


Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович








Харків 2024
1 МЕТА


Опанувати основні методи рефакторингу коду, використовуючи реальні приклади з програмних проєктів. Необхідно навчитися виявляти проблеми у коді, вибрати відповідні методи для їх вирішення та вдосконалювати якість програмного забезпечення, не змінюючи його функціональності.


2 ВСТУП


Рефакторинг — це процес покращення внутрішньої структури коду без зміни його зовнішньої поведінки. Він спрямований на підвищення читабельності, простоти супроводу та підтримуваності програмного забезпечення, одночасно залишаючи функціонал програми незмінним.
Рефакторинг дозволяє зробити код зрозумілішим, зменшити кількість помилок у майбутньому та полегшити внесення змін. Основні методи рефакторингу включають: заміну магічних чисел на константи, ізоляцію складної логіки в окремі функції, покращення іменування змінних, видалення дублювання коду тощо.
Ця робота допоможе ознайомитися з практичними аспектами рефакторингу коду та застосувати отримані знання для створення якісного, чистого та легко підтримуваного програмного забезпечення.








3 ХІД РОБОТИ


Посилання на відео з демонстрацією рекомендацій на мові програмування C++ наведено у додатку А.
Слайди з презентації, які ілюструють виконання даної практичної роботи наведено у додатку Е.
3.1. Метод «Заміна тимчасової змінної запитом»
3.1.1. Опис методу рефакторингу
Цей метод передбачає заміну тимчасових змінних викликами методів або функцій, які безпосередньо обчислюють потрібне значення. Це допомагає уникнути зберігання проміжних результатів у локальних змінних. Метод покращує модульність, розділяючи складні обчислення на менші функції. У результаті, код стає більш читабельним і легшим для підтримки.
Призначення: Спростити логіку обчислень і зменшити залежність від тимчасових змінних.
Переваги: Покращує читабельність і дозволяє перевикористовувати код у різних частинах програми.
3.1.2. Опис проблеми в коді до рефакторингу
У коді використовували тимчасові змінні, такі як «basePrice» і «discount», які обчислювалися, а потім використовувалися лише в одному місці. Це створювало надлишкову складність, оскільки доводилося шукати їхнє визначення для розуміння логіки роботи коду.
Код наведено в Додатку Б, на рядках 1-12.
3.1.3. Обґрунтування вибору методу рефакторингу
Використання методу або функції замість тимчасової змінної робить код більш лаконічним і сприяє усуненню надлишковості. Це також спрощує подальше обслуговування, адже внесення змін до логіки обчислення можливе в єдиному місці.
3.1.4. Опис коду після рефакторингу
Тимчасові змінні були замінені викликами методів:
* «calculateBasePrice()» замість «basePrice».
* «getDiscount()» замість «discount».
Код наведено в Додатку Б, на рядках 13-32.
3.1.5. Як ми використали цей метод та що змінилось у коді після рефакторингу
Метод реалізовано через створення нових функцій, які повертають значення, раніше привласнені тимчасовим змінним. Після рефакторингу значення обчислюється й використовується безпосередньо, що спрощує читання та аналіз коду.
3.1.6. Переваги отриманого коду після рефакторингу
1. Зменшення складності: Код став коротшим і зрозумілішим.
2. Покращення підтримуваності: Зміни до логіки тепер зосереджені у функціях.
3. Усунення дублювання: Всі обчислення виконуються у відповідних функціях, уникнувши зайвого дублювання.


3.2. Метод «Видалення присвоюваних значень параметрам»
3.2.1. Опис методу рефакторингу
Метод "Видалення присвоюваних значень параметрам" спрямований на створення локальної копії параметра для обчислень замість його модифікації. Це зменшує ризик побічних ефектів і полегшує аналіз роботи функції. 
Призначення: Забезпечити прозорість і передбачуваність функцій, залишаючи вхідні параметри незмінними.
Переваги: Поліпшує розуміння функцій і запобігає побічним ефектам.
3.2.2. Опис проблеми в коді до рефакторингу
Функція «applyDiscount» змінювала вхідний параметр «order.totalPrice», зменшуючи його значення. Це створювало побічні ефекти, що могло призвести до небажаних змін у вихідних даних.
Код наведено в Додатку В, на рядках 1-7.
3.2.3. Обґрунтування вибору методу рефакторингу
Заміна параметра локальною змінною дозволяє функції працювати автономно, забезпечуючи збереження початкових значень. Це особливо важливо для функцій, які працюють із зовнішніми даними.
3.2.4. Опис коду після рефакторингу
Параметр «order.totalPrice» більше не змінюється. Логіка обчислення тепер використовує локальну змінну «discountedPrice», яка містить фінальне значення.
Код наведено в Додатку Б, на рядках 8-14.
3.2.5. Як ми використали цей метод та що змінилось у коді після рефакторингу
Модифікація вхідного параметра була замінена на створення локальної змінної для обчислень. Це усунуло побічні ефекти й покращило передбачуваність функції.
3.2.6. Переваги отриманого коду після рефакторингу
1. Відсутність побічних ефектів: Оригінальні параметри функції залишаються незмінними.
2. Читабельність: Логіка роботи функції стала зрозумілою.
3. Придатність до перевикористання: Функція стала більш універсальною.


3.3. Метод «Заміна магічних чисел на символьну константу»
3.3.1. Опис методу рефакторингу
Цей метод передбачає заміну числових значень, які використовуються без пояснень у коді (так званих магічних чисел), на названі константи. Завдяки цьому кожне число отримує зрозумілу назву, яка відображає його суть. У разі необхідності зміни числа, це можна зробити централізовано. Метод також допомагає уникнути повторень у коді.
Призначення: Зробити код більш читабельним, уникаючи плутанини з незрозумілими числовими значеннями.
Переваги: Покращує підтримуваність і дозволяє легко змінювати ключові значення.
3.3.2. Опис проблеми в коді до рефакторингу
У коді використовувалися "магічні" числа (18, 65, 20.5, 0.15), які не пояснювали своє значення. Це створювало плутанину й ризик помилок при зміні значень.
Код наведено в Додатку В, на рядках 1-8
3.3.3. Обґрунтування вибору методу рефакторингу
Іменовані константи додають контекст і пояснення до числових значень, що робить код самодокументованим. Крім того, централізоване управління значеннями спрощує їхнє оновлення.
3.3.4. Опис коду після рефакторингу
Числові значення були замінені на константи:
* 18 → MIN_WORKING_AGE
* 65 → MAX_WORKING_AGE
* 20.5 → HOURLY_RATE
* 0.15 → TAX_RATE
Код наведено в Додатку В, на рядках 8-20.
3.3.5. Як ми використали цей метод та що змінилось у коді після рефакторингу
Визначені іменовані константи використовуються в усіх відповідних місцях коду, забезпечуючи зрозумілість і централізоване управління числовими значеннями.
3.3.6. Переваги отриманого коду після рефакторингу
1. Читабельність: Константи пояснюють призначення чисел у коді.
2. Легкість модифікації: Зміни значень вимагають редагування лише в одному місці.
3. Зрозумілість: Кожне значення стало зрозумілим завдяки іменам констант.
4. Загальний приклад із використанням усіх методів
4.1. Опис методу рефакторингу
У цьому прикладі застосовано комбінацію трьох методів:
* «Заміна тимчасової змінної запитом» для спрощення обчислень і підвищення читабельності.
* «Видалення присвоюваних значень параметрам» для зменшення побічних ефектів у функціях.
* «Заміна магічних чисел на символьну константу» для усунення незрозумілих числових значень і підвищення зрозумілості коду.
4.2. Опис проблеми в коді до рефакторингу
Функція «calculateFinalPrice» була перевантажена логікою, використовувала магічні числа та залежала від тимчасових змінних. Це ускладнювало розуміння та модифікацію коду, збільшувало ризик помилок і ускладнювало повторне використання логіки.
Код наведено в Додатку Д, на рядках 1–10.
4.3. Обґрунтування вибору методу рефакторингу
Поєднання методів дало змогу:
1. Розбити функцію на менші частини: це зробило код більш модульним і зрозумілим.
2. Використати константи: це зменшило залежність від магічних чисел і підвищило гнучкість.
3. Зменшити побічні ефекти: зробивши параметри функції незмінними, забезпечено більшу передбачуваність і надійність.
4.4. Опис коду після рефакторингу
Функцію calculateFinalPrice було розбито на кілька менших функцій:
* «applySurcharge» — для додавання надбавки, якщо ціна нижче певного рівня.
* «calculateDiscount» — для обчислення знижки залежно від кількості товарів.
* «calculateTax» — для обчислення податку залежно від ставки.
Усі магічні числа замінено на константи: «LOW_PRICE_SURCHARGE», «DISCOUNT_RATE», «TAX_RATE».
Код наведено в Додатку Д, на рядках 10–32.
4.5. Використання методу та зміни після рефакторингу
Методи рефакторингу дозволили:
   * Винести обчислення в окремі функції, спрощуючи основну функцію «calculateFinalPrice».
   * Усунути магічні числа, що підвищило зрозумілість коду для розробників.
   * Зменшити кількість тимчасових змінних, завдяки чому код став більш компактним і легким у підтримці.
4.6. Переваги отриманого коду після рефакторингу
   1. Структурованість: основна функція стала значно простішою, що полегшує її розуміння.
   2. Модульність: нові функції можна використовувати повторно в інших частинах програми.
   3. Підтримуваність: усі магічні числа винесено в константи, що спрощує їх модифікацію.
   4. Читабельність: код став легшим для сприйняття й аналізу.
Завдяки цьому код відповідає кращим практикам розробки та полегшує внесення майбутніх змін.
















































ВИСНОВКИ


У ході роботи були вивчені основні методи рефакторингу коду та їх застосування на реальних прикладах. Було набуто практичних навичок виявлення проблем у коді та їх вирішення за допомогою відповідних методів. У результаті підвищено якість коду, його читабельність і легкість супроводу, що забезпечує зручність подальшої роботи з програмним забезпеченням.




























СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ


   1. Fowler, M. Refactoring: Improving the Design of Existing Code. URL: https://martinfowler.com/books/refactoring.html (дата звернення: 04.12.2024).

   2. Офіційна документація JetBrains. JetBrains Documentation. URL: https://www.jetbrains.com/help/ (дата звернення: 04.12.2024).

   3. Офіційна документація Visual Studio. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/visualstudio/ (дата звернення: 04.12.2024).

   4. GitHub. GitHub Documentation. URL: https://docs.github.com/ (дата звернення: 04.12.2024).





































ДОДАТОК А
Відео-посилання на YouTube


https://youtu.be/oHT_TFJVkPU


































































 ДОДАТОК Б
     Код програми




Заміна тимчасової змінної запитом:
        1.  // До рефакторингу
2.  double calculateOrderTotal(const Order& order) {
3.      double subTotal = 0.0;
4.      for (const auto& item : order.items) {
5.          subTotal += item.price * item.quantity;
6.      }
7.  
8.      double discount = (order.isVip) ? subTotal * 0.1 : 0.0;
9.      double tax = subTotal * 0.2;
10.     return subTotal - discount + tax;
11. }
12. 
13. // Після рефакторингу
14. double calculateSubTotal(const Order& order) {
15.     double subTotal = 0.0;
16.     for (const auto& item : order.items) {
17.         subTotal += item.price * item.quantity;
18.     }
19.     return subTotal;
20. }


ДОДАТОК Б
  Код програми


21. 
22. double calculateDiscount(const Order& order) {
23.     return (order.isVip) ? calculateSubTotal(order) * 0.1 : 0.0;
24. }
25. 
26. double calculateTax(const Order& order) {
27.     return calculateSubTotal(order) * 0.2;
28. }
29. 
30. double calculateOrderTotal(const Order& order) {
31.     return calculateSubTotal(order) - calculateDiscount(order) + calculateTax(order);
32. }
























ДОДАТОК В
 Код програми


Видалення присвоюваних значень параметрам:
1.  // До рефакторингу
2.  void applyDiscount(Order& order) {
3.      if (order.totalPrice > 1000) {
4.          order.totalPrice -= order.totalPrice * 0.1;
5.      }
6.      order.totalPrice -= order.loyaltyPoints * 0.05;
7.  }
8.  
9.  // Після рефакторингу
10. double calculateDiscountedPrice(const Order& order) {
11.     double discount = 0.0;
12.     if (order.totalPrice > 1000) {
13.         discount += order.totalPrice * 0.1;
14.     }
15.     discount += order.loyaltyPoints * 0.05;
16.     return order.totalPrice - discount;
17. }






















ДОДАТОК Г
Код програми




Заміна магічних чисел на символьну константу:


1.  // До рефакторингу
2.  if (employee.age >= 18 && employee.age <= 65) {
3.      employee.salary = employee.hoursWorked * 20.5;
4.      if (employee.salary > 5000) {
5.          employee.salary -= employee.salary * 0.15;
6.      }
7.  }
8.  
9.  // Після рефакторингу
10. const int MIN_WORKING_AGE = 18;
11. const int MAX_WORKING_AGE = 65;
12. const double HOURLY_RATE = 20.5;
13. const double TAX_RATE = 0.15;
14. 
15. if (employee.age >= MIN_WORKING_AGE && employee.age <= MAX_WORKING_AGE) {
16.     employee.salary = employee.hoursWorked * HOURLY_RATE;
17.     if (employee.salary > 5000) {
18.         employee.salary -= employee.salary * TAX_RATE;
19.     }
20. }




ДОДАТОК Д
Код програми




1.  // До рефакторингу
2.  double calculateFinalPrice(double price, double taxRate, int quantity) {
3.      if (price < 500) {
4.          price += 50;
5.      }
6.      double discount = (quantity > 10) ? price * 0.1 : 0;
7.      double tax = price * taxRate;
8.      return (price - discount + tax);
9.  }
10. 
11. // Після рефакторингу
12. const double LOW_PRICE_SURCHARGE = 50.0;
13. const double DISCOUNT_RATE = 0.1;
14. 
15. double applySurcharge(double price) {
16.     return (price < 500) ? price + LOW_PRICE_SURCHARGE : price;
17. }
18. 
19. double calculateDiscount(double price, int quantity) {
20.     return (quantity > 10) ? price * DISCOUNT_RATE : 0;
21. }
22. 
23. double calculateTax(double price, double taxRate) {


ДОДАТОК Д
Код програми




24.     return price * taxRate;
25. }
26. 
27. double calculateFinalPrice(double price, double taxRate, int quantity) {
28.     double adjustedPrice = applySurcharge(price);
29.     double discount = calculateDiscount(adjustedPrice, quantity);
30.     double tax = calculateTax(adjustedPrice, taxRate);
31.     return (adjustedPrice - discount + tax);
32. }




































ДОДАТОК Е
Скріншоти презентації
Рисунок Е.1 – Титульний лист


