Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії








ЗВІТ
з практичного заняття №2  
з дисципліни  «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»












            Виконав 
ст. гр ПЗПІ-22-3
 Бут Ростислав Сергійович


                                                           Перевірив
   ст. викладач кафедри ПІ
Сокорчук Ігор Петрович








Харків 2024
1 МЕТА


Опанувати основні методи рефакторингу коду, використовуючи реальні приклади з програмних проєктів. Необхідно навчитися виявляти проблеми у коді, вибрати відповідні методи для їх вирішення та вдосконалювати якість програмного забезпечення, не змінюючи його функціональності.


2 ВСТУП


Рефакторинг — це процес покращення внутрішньої структури коду без зміни його зовнішньої поведінки. Він спрямований на підвищення читабельності, простоти супроводу та підтримуваності програмного забезпечення, одночасно залишаючи функціонал програми незмінним.
Рефакторинг дозволяє зробити код зрозумілішим, зменшити кількість помилок у майбутньому та полегшити внесення змін. Основні методи рефакторингу включають: заміну магічних чисел на константи, ізоляцію складної логіки в окремі функції, покращення іменування змінних, видалення дублювання коду тощо.
Ця робота допоможе ознайомитися з практичними аспектами рефакторингу коду та застосувати отримані знання для створення якісного, чистого та легко підтримуваного програмного забезпечення.








3 ХІД РОБОТИ


Посилання на відео з демонстрацією рекомендацій на мові програмування C++ наведено у додатку А.
3.1. Метод «Заміна тимчасової змінної запитом»
3.1.1. Опис методу рефакторингу


Цей метод передбачає заміну тимчасових змінних викликами методів або функцій, які безпосередньо обчислюють потрібне значення. Це допомагає уникнути зберігання проміжних результатів у локальних змінних. Метод покращує модульність, розділяючи складні обчислення на менші функції. У результаті, код стає більш читабельним і легшим для підтримки.
Призначення: Спростити логіку обчислень і зменшити залежність від тимчасових змінних.
Переваги: Покращує читабельність і дозволяє перевикористовувати код у різних частинах програми.
3.1.2. Опис проблеми в коді до рефакторингу
Код до рефакторингу містить тимчасову змінну «subTotal», яка використовується для обчислення кількох значень, таких як знижка та податки. Це ускладнює розуміння і підтримку коду, оскільки будь-які зміни в логіці обчислення «subTotal» вимагають перегляду усіх місць, де вона використовується. Логіка сконцентрована в одному методі «calculateOrderTotal», що призводить до низької гнучкості та ускладнень у тестуванні окремих частин алгоритму. 
Код наведено в Додатку Б, на рядках 1-12.
3.1.3. Обґрунтування вибору методу рефакторингу
Метод «Заміна тимчасової змінної запитом» обраний для покращення розділення відповідальностей у коді. Цей підхід дозволяє виділити кожен етап обчислень у самостійні функції, роблячи код модульним і більш зрозумілим.
3.1.4. Опис коду після рефакторингу
Після рефакторингу тимчасова змінна «subTotal» була замінена окремою функцією «calculateSubTotal», яка обчислює суму вартості замовлення. Додано дві нові функції: «calculateDiscount» для обчислення знижки та «calculateTax» для підрахунку податку. Основна функція «calculateOrderTotal» тепер викликає ці допоміжні функції, що значно спрощує її логіку.
Код наведено в Додатку Б, на рядках 13-32.
3.1.5. Як використано метод та що змінилось у коді після рефакторингу
Метод реалізовано через створення нових функцій, які повертають значення, раніше привласнені тимчасовим змінним. Після рефакторингу значення обчислюється й використовується безпосередньо, що спрощує читання та аналіз коду.
3.1.6. Переваги отриманого коду після рефакторингу
Рефакторинг зменшив залежність між частинами коду та поліпшив його модульність. Логіка обчислень тепер ізольована в самостійних функціях, що робить код простішим для читання, тестування та модифікації. Крім того, це забезпечує кращу повторне використання функцій у разі подібних обчислень в інших частинах програми.


3.2. Метод «Видалення присвоюваних значень параметрам»
3.2.1. Опис методу рефакторингу


Метод «Видалення присвоюваних значень параметрам» спрямований на створення локальної копії параметра для обчислень замість його модифікації. Це зменшує ризик побічних ефектів і полегшує аналіз роботи функції. 
Призначення: Забезпечити прозорість і передбачуваність функцій, залишаючи вхідні параметри незмінними.
Переваги: Поліпшує розуміння функцій і запобігає побічним ефектам.
3.2.2. Опис проблеми в коді до рефакторингу
У коді до рефакторингу змінюється параметр «order.totalPrice», що передається у функцію. Це створює плутанину, оскільки ззовні важко було зрозуміти, як саме змінюється початковий об'єкт. Логіка обчислення знижки і зменшення ціни через використання бонусних балів була захована всередині однієї функції. Це знижує гнучкість коду, а внесення змін у функцію вимагає значних зусиль. 
Код наведено в Додатку В, на рядках 1-7.


3.2.3. Обґрунтування вибору методу рефакторингу
Метод «Видалення присвоюваних значень параметрам» був обраний для уникнення непередбачуваної поведінки коду, що виникає через зміну об'єкта, переданого у функцію. Він також допоміг ізолювати обчислення у самостійну функцію для зручності повторного використання.
3.2.4. Опис коду після рефакторингу
Після рефакторингу обчислення фінальної ціни були винесені в окрему функцію «calculateDiscountedPrice», яка приймає «order» як параметр і повертає нове значення фінальної ціни. Замість зміни «order.totalPrice» у функції, тепер результат обчислень можна зберігати в окремій змінній. 
Код наведено в Додатку Б, на рядках 8-14.
3.2.5. Як використано метод та що змінилось у коді після рефакторингу
Замінено пряме присвоєння значень вхідному параметру на обчислення результату в локальній змінній, що повертається як результат функції. Це покращило прозорість коду та спростило його підтримку.
3.2.6. Переваги отриманого коду після рефакторингу
Отриманий код став більш безпечним і передбачуваним, оскільки тепер функція не змінює об'єкт, що передається у параметрі. Логіка обчислень ізольована у функції «calculateDiscountedPrice», що полегшує її використання та тестування. Загальна структура коду стала зрозумілішою та більш підтримуваною.


3.3. Метод «Заміна магічних чисел на символьну константу»
3.3.1. Опис методу рефакторингу


Цей метод передбачає заміну числових значень, які використовуються без пояснень у коді (так званих магічних чисел), на названі константи. Завдяки цьому кожне число отримує зрозумілу назву, яка відображає його суть. У разі необхідності зміни числа, це можна зробити централізовано. Метод також допомагає уникнути повторень у коді.
Призначення: Зробити код більш читабельним, уникаючи плутанини з незрозумілими числовими значеннями.
Переваги: Покращує підтримуваність і дозволяє легко змінювати ключові значення.
3.3.2. Опис проблеми в коді до рефакторингу
Код до рефакторингу містить числові значення 18, 65, 20.5 і 0.15, які безпосередньо використовувалися у виразах. Це ускладнює розуміння коду та внесення змін у майбутньому. Наприклад, важко здогадатися, що числа 18 і 65 позначають мінімальний та максимальний вік працівників. Внесення змін до таких чисел могло призвести до помилок.
Код наведено в Додатку В, на рядках 1-8
3.3.3. Обґрунтування вибору методу рефакторингу
Метод «Заміна магічних чисел на символьну константу» був обраний для підвищення зрозумілості коду, а також для спрощення внесення змін у майбутньому. Завдяки використанню констант, код стає більш самодокументованим і легким для розуміння.
3.3.4. Опис коду після рефакторингу
Після рефакторингу магічні числа були замінені описовими константами: «MIN_WORKING_AGE», «MAX_WORKING_AGE», «HOURLY_RATE» і «TAX_RATE». Ці константи були визначені у верхній частині блоку коду, що полегшує їх перегляд і зміну. Основна логіка залишилася незмінною, але її читабельність значно покращилася.
Код наведено в Додатку В, на рядках 8-20.
3.3.5. Як використано метод та що змінилось у коді після рефакторингу
Метод був застосований шляхом оголошення відповідних констант із зрозумілими іменами та заміни ними магічних чисел у коді. Це дозволило уникнути ситуацій, коли значення чисел треба здогадуватись із контексту, та зменшило ризик внесення помилок.
3.3.6. Переваги отриманого коду після рефакторингу
Отриманий код став більш зрозумілим і легким для модифікації, оскільки всі важливі числові значення тепер представлені у вигляді констант із описовими іменами. Це покращило читабельність та зробило код менш схильним до помилок під час внесення змін.


4. Загальний приклад із використанням усіх методів
4.1. Опис методу рефакторингу
У цьому прикладі застосовано комбінацію трьох методів:
* «Заміна тимчасової змінної запитом» для спрощення обчислень і підвищення читабельності.
* «Видалення присвоюваних значень параметрам» для зменшення побічних ефектів у функціях.
* «Заміна магічних чисел на символьну константу» для усунення незрозумілих числових значень і підвищення зрозумілості коду.
4.2. Опис проблеми в коді до рефакторингу
Код до рефакторингу був складним для розуміння та внесення змін. Тимчасові змінні використовувалися для збереження обчислень, що погіршувало прозорість. Змінювався параметр «price», переданий у функцію, що могло призвести до непередбачуваних наслідків. Також у коді було багато магічних чисел, таких як 500, 50, і 0.1, що ускладнювало зрозумілість логіки. 
Код наведено в Додатку Д, на рядках 1–10.
4.3. Обґрунтування вибору методу рефакторингу
Поєднання методів дало змогу:
1. Розбити функцію на менші частини: це зробило код більш модульним і зрозумілим.
2. Використати константи: це зменшило залежність від магічних чисел і підвищило гнучкість.
3. Зменшити побічні ефекти: зробивши параметри функції незмінними, забезпечено більшу передбачуваність і надійність.
4.4. Опис коду після рефакторингу
Після рефакторингу магічні числа були замінені константами, такими як «LOW_PRICE_SURCHARGE» і «DISCOUNT_RATE». Обчислення знижки, податку, та додаткової націнки були виділені в окремі функції: «applySurcharge», «calculateDiscount», «calculateTax». Вхідний параметр «price» більше не змінюється безпосередньо у функції. Фінальна ціна обчислюється шляхом виклику цих функцій у функції «calculateFinalPrice».
Код наведено в Додатку Д, на рядках 10–32.
4.5. Використання методу та зміни після рефакторингу
Метод «Заміна тимчасової змінної запитом» допоміг зробити функцію «calculateFinalPrice» більш компактною і зрозумілою. Метод «Видалення присвоюваних значень параметрам» забезпечив захист вхідного параметра price від змін, що підвищило надійність коду. Метод «Заміна магічних чисел на символьну константу» зробив код самодокументованим і зручним для внесення змін.
4.6. Переваги отриманого коду після рефакторингу
Код став більш структурованим і простим для тестування. Логіка обчислень стала зрозумілішою завдяки використанню окремих функцій і констант. Рефакторинг підвищив гнучкість і підтримуваність коду, дозволивши легко змінювати параметри обчислень (наприклад, значення знижки чи податку) без ризику помилок.
Слайди з презентації, які ілюструють виконання даної практичної роботи наведено у додатку Е.










ВИСНОВКИ


У ході роботи були вивчені основні методи рефакторингу коду та їх застосування на реальних прикладах. Було набуто практичних навичок виявлення проблем у коді та їх вирішення за допомогою відповідних методів. У результаті підвищено якість коду, його читабельність і легкість супроводу, що забезпечує зручність подальшої роботи з програмним забезпеченням.




























СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ


1. Fowler, M. Refactoring: Improving the Design of Existing Code. URL: https://martinfowler.com/books/refactoring.html (дата звернення: 04.12.2024).

2. Офіційна документація JetBrains. JetBrains Documentation. URL: https://www.jetbrains.com/help/ (дата звернення: 04.12.2024).

3. Офіційна документація Visual Studio. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/visualstudio/ (дата звернення: 04.12.2024).

4. GitHub. GitHub Documentation. URL: https://docs.github.com/ (дата звернення: 04.12.2024).





































ДОДАТОК А
Відео-посилання на YouTube


https://youtu.be/oHT_TFJVkPU


































































 ДОДАТОК Б
     Код програми




Заміна тимчасової змінної запитом:
        1.  // До рефакторингу
2.  double calculateOrderTotal(const Order& order) {
3.      double subTotal = 0.0;
4.      for (const auto& item : order.items) {
5.          subTotal += item.price * item.quantity;
6.      }
7.  
8.      double discount = (order.isVip) ? subTotal * 0.1 : 0.0;
9.      double tax = subTotal * 0.2;
10.     return subTotal - discount + tax;
11. }
12. 
13. // Після рефакторингу
14. double calculateSubTotal(const Order& order) {
15.     double subTotal = 0.0;
16.     for (const auto& item : order.items) {
17.         subTotal += item.price * item.quantity;
18.     }
19.     return subTotal;
20. }


ДОДАТОК Б
  Код програми


21. 
22. double calculateDiscount(const Order& order) {
23.     return (order.isVip) ? calculateSubTotal(order) * 0.1 : 0.0;
24. }
25. 
26. double calculateTax(const Order& order) {
27.     return calculateSubTotal(order) * 0.2;
28. }
29. 
30. double calculateOrderTotal(const Order& order) {
31.     return calculateSubTotal(order) - calculateDiscount(order) + calculateTax(order);
32. }
























ДОДАТОК В
 Код програми


Видалення присвоюваних значень параметрам:
1.  // До рефакторингу
2.  void applyDiscount(Order& order) {
3.      if (order.totalPrice > 1000) {
4.          order.totalPrice -= order.totalPrice * 0.1;
5.      }
6.      order.totalPrice -= order.loyaltyPoints * 0.05;
7.  }
8.  
9.  // Після рефакторингу
10. double calculateDiscountedPrice(const Order& order) {
11.     double discount = 0.0;
12.     if (order.totalPrice > 1000) {
13.         discount += order.totalPrice * 0.1;
14.     }
15.     discount += order.loyaltyPoints * 0.05;
16.     return order.totalPrice - discount;
17. }






















ДОДАТОК Г
Код програми




Заміна магічних чисел на символьну константу:


1.  // До рефакторингу
2.  if (employee.age >= 18 && employee.age <= 65) {
3.      employee.salary = employee.hoursWorked * 20.5;
4.      if (employee.salary > 5000) {
5.          employee.salary -= employee.salary * 0.15;
6.      }
7.  }
8.  
9.  // Після рефакторингу
10. const int MIN_WORKING_AGE = 18;
11. const int MAX_WORKING_AGE = 65;
12. const double HOURLY_RATE = 20.5;
13. const double TAX_RATE = 0.15;
14. 
15. if (employee.age >= MIN_WORKING_AGE && employee.age <= MAX_WORKING_AGE) {
16.     employee.salary = employee.hoursWorked * HOURLY_RATE;
17.     if (employee.salary > 5000) {
18.         employee.salary -= employee.salary * TAX_RATE;
19.     }
20. }




ДОДАТОК Д
Код програми




1.  // До рефакторингу
2.  double calculateFinalPrice(double price, double taxRate, int quantity) {
3.      if (price < 500) {
4.          price += 50;
5.      }
6.      double discount = (quantity > 10) ? price * 0.1 : 0;
7.      double tax = price * taxRate;
8.      return (price - discount + tax);
9.  }
10. 
11. // Після рефакторингу
12. const double LOW_PRICE_SURCHARGE = 50.0;
13. const double DISCOUNT_RATE = 0.1;
14. 
15. double applySurcharge(double price) {
16.     return (price < 500) ? price + LOW_PRICE_SURCHARGE : price;
17. }
18. 
19. double calculateDiscount(double price, int quantity) {
20.     return (quantity > 10) ? price * DISCOUNT_RATE : 0;
21. }
22. 
23. double calculateTax(double price, double taxRate) {


ДОДАТОК Д
Код програми




24.     return price * taxRate;
25. }
26. 
27. double calculateFinalPrice(double price, double taxRate, int quantity) {
28.     double adjustedPrice = applySurcharge(price);
29.     double discount = calculateDiscount(adjustedPrice, quantity);
30.     double tax = calculateTax(adjustedPrice, taxRate);
31.     return (adjustedPrice - discount + tax);
32. }




































ДОДАТОК Е
Скріншоти презентації


  

Рисунок Е.1 – Титульна сторінка


  

Рисунок Е.2 – Вступ: визначення рефакторингу
ДОДАТОК Е
Скріншоти презентації


  

Рисунок Е.3 – Опис першого методу рефакторингу
  

Рисунок Е.4 – Код після застосування першого методу рефакторингу
ДОДАТОК Е
Скріншоти презентації


  

Рисунок Е.5 – Опис другого методу рефакторингу
  

Рисунок Е.6 – Код після застосування другого методу
ДОДАТОК Е
Скріншоти презентації


  

Рисунок Е.7 – Опис третього методу рефакторингу
  

Рисунок Е.8 – Приклад із використанням усіх методів рефакторингу
ДОДАТОК Е
Скріншоти презентації


  

Рисунок Е.9 – Приклад з використанням всіх методів
  

Рисунок Е.10 – Огляд інструментів для рефакторингу коду
ДОДАТОК Е
Скріншоти презентації


  

Рисунок Е.11 – Висновки щодо використання рефакторингу
  

Рисунок Е.12 – Список літератури та джерел