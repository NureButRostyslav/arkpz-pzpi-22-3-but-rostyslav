Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії








ЗВІТ
з практичного заняття №1  
з дисципліни  «Аналіз та рефакторинг коду»
на тему: «Правила оформлення програмного коду»












Виконав 
ст. гр ПЗПІ-22-3
Бут Ростислав Сергійович


Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович










Харків 2024
1 МЕТА


Ознайомитися з основними рекомендаціями та кращими практиками написання чистого, читабельного та підтримуваного коду на мові C++. Вивчити особливості мови, що сприяють створенню ефективного коду, та застосувати отримані знання для покращення якості написаного коду.  


2 ВСТУП


C++ є потужною мовою об'єктно-орієнтованого програмування, яка дозволяє розробникам створювати високопродуктивні програми, використовуючи низькорівневий доступ до пам’яті, шаблони та об’єкти. Особливості мови, такі як об’єктно-орієнтовані підходи, доступ до системних ресурсів і швидкодія, роблять її популярною серед розробників системного програмного забезпечення, ігор та графічних застосунків. При написанні коду важливо дотримуватися певних рекомендацій, які покращують його читабельність, підтримуваність та надійність. Цей звіт включає опис таких рекомендацій та їх практичне застосування в C++ із прикладами. 


3 ХІД РОБОТИ
Посилання на відео з демонстрацією рекомендацій оформлення коду на мові програмування C++ наведено у додатку А.


1. Рекомендація: Використовуйте осмислені назви змінних та функцій.
* Чому це важливо? Осмислені назви дають зрозуміти, яке значення або функцію має змінна чи функція. Це зменшує ймовірність помилок, оскільки зменшується необхідність постійно звертатися до коментарів.
* Наслідки недотримання: Якщо назви неясні або абревіатури не є стандартними, код може бути важким для розуміння, і це може призвести до додаткових помилок під час зміни чи модифікації коду.
* Вплив на підтримку: Чіткі назви змінних і функцій полегшують підтримку, оскільки нові розробники можуть швидше орієнтуватися в коді.
* Приклад поганого та гарного коду щодо рекомендацій 1:
1.  // Поганий приклад
2.  void calculate(int y, int z) {
3.      int x = y + z;
4.      cout << "Sum: " << x << endl;
5.  }
6.  
7.  // Гарний приклад
8.  void calculateSum(int firstValue, int secondValue) {
9.      int sumResult = firstValue + secondValue;
10.     cout << "Sum: " << sumResult << endl;
11. }
12. 
2. Рекомендація: Використовуйте посилання замість вказівників, щоб уникнути перевірок на nullptr.
* Чому це важливо? Використання посилань замість вказівників допомагає уникнути необхідності постійно перевіряти на nullptr, що робить код простішим та менш схильним до помилок.
* Наслідки недотримання: Якщо використовуються вказівники без належної перевірки, це може призвести до аварійних завершень програми через доступ до некоректної пам'яті.
* Вплив на підтримку: Посилання значно спрощують код і зменшують кількість потенційних помилок у майбутньому, що позитивно впливає на підтримку програми.
* Приклад поганого та гарного коду щодо рекомендацій 2:
13. // Поганий приклад
14. void process(BankAccount* account) {
15.     if (account != nullptr) {
16.         account->performAction();
17.     }
18. }
19. 
20. // Гарний приклад
21. void executeTransaction(BankAccount& bankAccount) {
22.     bankAccount.performAction();
23. }
24. 
3. Рекомендація: Уникайте використання глобальних змінних.
* Чому це важливо? Глобальні змінні можуть бути змінені в будь-якому місці програми, що ускладнює відслідковування їхнього стану. Вони можуть призвести до непередбачуваних ефектів, коли зміни впливають на різні частини програми.
* Наслідки недотримання: Використання глобальних змінних може призвести до важких для виявлення помилок, особливо у великих системах, де важко відстежити, де і коли змінюється глобальна змінна.
* Вплив на підтримку: Глобальні змінні роблять код важким для розширення та модифікації, оскільки змінні можуть бути випадково змінені в різних частинах програми.
* Приклад поганого та гарного коду щодо рекомендацій 3:
25. // Поганий приклад
26. int result;
27. 
28. void calculate(int operand1, int operand2) {
29.     result = operand1 + operand2;
30.     cout << "Sum: " << result << endl;
31. }
32. 
33. // Гарний приклад
34. void calculateSum(int firstOperand, int secondOperand) {
35.     int sumResult = firstOperand + secondOperand;
36.     cout << "Sum: " << sumResult << endl;
37. }
38. 
4. Рекомендація: Використовуйте функції та методи замість повторення коду.
* Чому це важливо? Повторення коду ускладнює його зміну в майбутньому. Якщо код змінюється в одному місці, потрібно бути впевненим, що ці зміни відображаються в кожному місці, де цей код повторюється.
* Наслідки недотримання: Копіювання і вставлення коду призводить до дублювання логіки, що робить систему складнішою для тестування та підтримки.
* Вплив на підтримку: Використання функцій та методів дозволяє централізовано змінювати логіку, що полегшує її підтримку та тестування.
* Приклад поганого та гарного коду щодо рекомендацій 4:
39. // Поганий приклад
40. int area1 = width * height;
41. int area2 = length * width;
42. int area3 = height * depth;
43. 
44. // Гарний приклад
45. int calculateArea(int width, int height) {
46.     return width * height;
47. }
48. 
49. int area1 = calculateArea(width, height);
50. int area2 = calculateArea(length, width);
51. int area3 = calculateArea(height, depth);
52. 
5. Рекомендація: Зберігайте функції простими та короткими.
* Чому це важливо? Простота функцій робить їх легкими для розуміння, тестування та повторного використання. Кожна функція повинна виконувати лише одну задачу.
* Наслідки недотримання: Якщо функція занадто велика і робить багато різних речей, її важче тестувати і зрозуміти, що вона насправді робить.
* Вплив на підтримку: Простота і короткість функцій робить їх більш надійними та легкими для змін, тому код легше підтримувати і розширювати.
* Приклад поганого та гарного коду щодо рекомендацій 5:
53. // Поганий приклад
54. int addAndMultiply(int value1, int value2) {
55.     int sum = value1 + value2;
56.     int product = value1 * value2;
57.     cout << "Sum: " << sum << endl;
58.     cout << "Product: " << product << endl;
59.     return sum;
60. }
61. 
62. // Гарний приклад
63. int calculateAddition(int firstNumber, int secondNumber) {
64.     return firstNumber + secondNumber;
65. }
66. 
6. Рекомендація: Завжди використовуйте {} і відступи для операторів керування.
* Чому це важливо? Використання фігурних дужок навіть для одноразових операторів допомагає уникнути логічних помилок, якщо код змінюється і з’являються нові строки після операторів.
* Наслідки недотримання: Можна випадково змінити структуру коду, додавши новий оператор, який може бути неочікувано виключений через відсутність фігурних дужок.
* Вплив на підтримку: Використання дужок для кожного блоку полегшує підтримку, оскільки будь-яка зміна коду не призведе до неочікуваних наслідків.
* Приклад поганого та гарного коду щодо рекомендацій 6:
67. // Поганий приклад
68. if (dataSize == 0) return;
69. for (int i = 0; i < 10; i++) cout << "ok" << endl;
70. 
71. // Гарний приклад
72. if (dataSize == 0) {
73.     return;
74. }
75. for (int index = 0; index < 10; ++index) {
76.     cout << "ok" << endl;
77. }
78. 
7. Рекомендація: Повертайте результати тестів напряму, без зайвих if/else.
* Чому це важливо? Спрощення умовних операторів робить код компактнішим, зменшує кількість помилок і полегшує розуміння результатів.
* Наслідки недотримання: Використання зайвих умов може зробити код громіздким і заплутаним, що ускладнює його аналіз.
* Вплив на підтримку: Мінімізація умовних перевірок робить код зрозумілішим, полегшуючи його підтримку та розширення в майбутньому.
* Приклад поганого та гарного коду щодо рекомендацій 7:
79. // Поганий приклад
80. if (a == b) {
81.     return true;
82. }
83. else {
84.     return false;
85. }
86. 
87. // Гарний приклад
88. return a == b;
89. 


8. Рекомендація: Уникайте "жорстко закодованих" значень.
* Чому це важливо? Використання констант дозволяє централізовано змінювати значення, що полегшує модифікацію коду і зменшує ймовірність помилок.
* Наслідки недотримання: Якщо значення безпосередньо закодовані в коді, змінити їх в декількох місцях стає складно, що збільшує ризик помилок.
* Вплив на підтримку: Використання констант значно полегшує процес оновлення коду, особливо в великих проектах.
* Приклад поганого та гарного коду щодо рекомендацій 8:
90. // Поганий приклад
91. int array[100];
92. for (int i = 0; i < 100; ++i) {
93.     array[i] = i;
94. }
95. 
96. // Гарний приклад
97. const int arraySize = 100;
98. 
99. int processArray() {
100.    int dataArray[arraySize];
101.    for (int index = 0; index < arraySize; ++index) {
102.        dataArray[index] = index;
103.    }
104.    return 0;
105. }
106. 
9. Рекомендація: Використовуйте правила для правильної обробки ресурсів (RAII).
* Чому це важливо? Патерн RAII дозволяє автоматично звільняти ресурси, що знижує ймовірність витоків пам'яті чи інших помилок, пов’язаних з неправильним управлінням ресурсами.
* Наслідки недотримання: Невикористання RAII може призвести до витоків пам’яті або ресурсів, що ускладнює підтримку програми.
* Вплив на підтримку: Використання RAII полегшує управління ресурсами та знижує ризики, зокрема в багатозадачних системах.
* Приклад поганого та гарного коду щодо рекомендацій 9:
107. // Поганий приклад
108. void readFile() {
109.     FILE* file = fopen("data.txt", "r");
110.     if (file) {
111.         char buffer[256];
112.         while (fgets(buffer, sizeof(buffer), file)) {
113.             cout << buffer;
114.         }
115.         fclose(file);
116.     }
117.     else {
118.         cerr << "Error opening file" << endl;
119.     }
120. }
121. 
122. // Гарний приклад
123. void readFile() {
124.     ifstream file("data.txt");
125.     if (!file.is_open()) {
126.         cerr << "Error opening file" << endl;
127.         return;
128.     }
129. 
130.     string line;
131.     while (getline(file, line)) {
132.         cout << line << endl;
133.     }
134. }
135. 
10. Рекомендація: Додавайте обробку помилок.
* Чому це важливо? Обробка помилок дозволяє забезпечити стабільну роботу програми навіть у випадку непередбачуваних ситуацій, що покращує досвід користувача.
* Наслідки недотримання: Якщо помилки не обробляються належним чином, програма може аварійно завершити свою роботу, що створює негативний досвід для користувачів.
* Вплив на підтримку: Наявність обробки помилок дозволяє швидко діагностувати та виправляти проблеми у програмі, що покращує її стабільність і забезпечує надійність.
* Приклад поганого та гарного коду щодо рекомендацій 10:
136. // Поганий приклад
137. int main() {
138.     int dividend, divisor;
139.     cout << "Enter dividend: ";
140.     cin >> dividend;
141.     cout << "Enter divisor: ";
142.     cin >> divisor;
143.     if (divisor == 0) {
144.         cout << "Error: Division by zero." << endl;
145.         return 1;
146.     }
147.     cout << "Result: " << dividend / divisor << endl;
148.     return 0;
149. }
150. 
151. // Гарний приклад
152. int divideNumbers() {
153.     int dividend, divisor;
154.     cout << "Enter dividend: ";
155.     cin >> dividend;
156.     cout << "Enter divisor: ";
157.     cin >> divisor;
158.     try {
159.         if (divisor == 0) {
160.             throw runtime_error("Error: Division by zero.");
161.         }
162.         cout << "Result: " << dividend / divisor << endl;
163.     }
164.     catch (runtime_error& err) {
165.         cout << err.what() << endl;
166.     }
167.     return 0;
168. }
Слайди з презентації, які ілюструють виконання даної практичної роботи наведено у додатку Б.






ВИСНОВКИ


В ході роботи було розглянуто основні рекомендації щодо написання якісного коду на C++. Використання осмислених назв, правильного форматування, обробки помилок та уникнення глобальних змінних робить код більш зрозумілим, легким у підтримці та масштабуванні.
Такі підходи дозволяють зменшити кількість помилок, полегшують співпрацю в команді та забезпечують довговічність програмного продукту.

























СПИСОК ВИКОРИСТАННИХ ДЖЕРЕЛ


1. Options, Text Editor, C/C++ Formatting – Visual Studio (2022). Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/visualstudio/ide/reference/options-text-editor-c-cpp-formatting?view=vs-2022 (дата звернення: 29.11.2024).

2. Master C++: Top Best Coding Practices. CppDepend Blog. URL: https://cppdepend.com/blog/master-cpp-top-best-coding-practices/ (дата звернення: 29.11.2024).

3. Google C++ Style Guide. URL: https://google.github.io/styleguide/cppguide.html (дата звернення: 29.11.2024).









































ДОДАТОК А
Відео-посилання на YouTube


https://www.youtube.com/watch?v=TY4i4N-Ru
 
































































ДОДАТОК Б
Скріншоти презентації




  

Рисунок Б.1 – Титульний лист


  

 
Рисунок Б.2 – Вступ


ДОДАТОК Б
Скріншоти презентації




  

 Рисунок Б.3 – Використовуйте осмислені назви 
  

 
Рисунок Б.4 – Використовуйте посилання замість вказівників 




ДОДАТОК Б
Скріншоти презентації




  

 
Рисунок Б.5 – Уникайте використання глобальних змінних


  
 
Рисунок Б.6 – Уникайте повторення коду


ДОДАТОК Б
Скріншоти презентації




  

Рисунок Б.7  – Зберігайте прості та короткі функції


   
Рисунок Б.8 – Використовуй відступи і дужки для операторів


ДОДАТОК Б
Скріншоти презентації




  

 
Рисунок Б.9 – Уникайте “жорстко кодованих значень”


   
Рисунок Б.10 – Повертайте результати тестів напряму
ДОДАТОК Б
Скріншоти презентації






  

 
Рисунок Б.11 – Використовуйте правила для правильної обробки ресурсів
 
  

Рисунок Б.12 – Додайте обробку помилок
ДОДАТОК Б
Скріншоти презентації


 


  
 
Рисунок Б.13 – Висновок щодо наданих рекомендацій


  
 
Рисунок Б.14 – Список використаних джерел
